import numpy as np

class Vertex:

    def __init__(self, pos, norm):
        self.pos = pos
        self.norm = norm
        self.orph = True
        self.edges = []

    def bind(self, edge):
        if len(self.edges) == 0:
            self.edges = [(edge, 0)]
            return
        vec = edge.vec_to(self)
        dir = np.cross(self.norm, vec)
        vy = self.edges[0][0].vec_to(self)
        diry = np.cross(self.norm, vy)
        dirx = np.cross(self.norm, diry)
        key = np.dot(dir, diry)/(np.linalg.norm(dir)*np.linalg.norm(diry))
        sign = np.dot(dir, dirx)/(np.linalg.norm(dir)*np.linalg.norm(dirx))
        if sign < 0:
            key += 3
        else:
            key = 1-key
        self.edges.append((edge, key))
        self.edges = sorted(self.edges, key=lambda e, k: k)
        
class Edge:

    def __init__(self, v1, v2):
        self.v = [v1, v2]

    def vec_to(self, vertex):
        if vertex == self.v[0]:
            return self.v[0].pos - self.v[1].pos
        else:
            return self.v[1].pos - self.v[0].pos

if __name__ == '__main__':
    v1 = Vertex(np.array((0, 0, 1)), np.array((0, 0, 1)))
    v2 = Vertex(np.array((1, 0, 0)), np.array((0, 0, 1)))
    v3 = Vertex(np.array((0, 1, 0)), np.array((0, 0, 1)))
    v4 = Vertex(np.array((-1, -1, 0)), np.array((0, 0, 1)))
    e1 = Edge(v1, v2)
    e2 = Edge(v1, v3)
    e3 = Edge(v1, v4)
    v1.bind(e1)
    v1.bind(e3)
    v1.bind(e2)
    for e, k in v1.edges:
        print k
